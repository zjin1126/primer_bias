#!/usr/bin/env python
import argparse
import pickle


class TaxNode:
    def __init__(self, tid, data=None, parent=None, child=None):
        self.parent = parent
        if child is None:
            self.child = []
        self.data = data
        self.tid = tid


TAX_ID = {}
TAX_TID = {}
TAX_NODE_OBJ = {}
ID_COUNT = -1
ROOT_NODE = TaxNode(ID_COUNT, data={'name': 'Root'})


def find_child_node(tid: int, node: TaxNode):
    for child_node in node.child:
        if child_node.tid == tid:
            return child_node
        else:
            result_node = find_child_node(tid, child_node)
            if result_node is not False:
                return result_node
    return False


def find_and_add(path: str, node: TaxNode):
    global ID_COUNT
    global TAX_ID
    for name in path.split(';'):
        if name not in TAX_ID:
            ID_COUNT += 1
            TAX_ID[name] = ID_COUNT
        result_node = find_child_node(TAX_ID[name], node)
        if isinstance(result_node, TaxNode):
            node = result_node
        else:
            nnode = TaxNode(TAX_ID[name], data={'name': name}, parent=node)
            node.child.append(nnode)
            node = nnode


def add_node(path: str):
    global ID_COUNT
    global TAX_ID
    prev = ROOT_NODE
    # for name in path.split(';'):
    #     if name not in TAX_ID:
    #         ID_COUNT += 1
    #         TAX_ID[name] = ID_COUNT
    #     if name not in TAX_NODE_OBJ:
    #         nnode = TaxNode(TAX_ID[name], data={'name': name}, parent=prev)
    #         prev.child.append(nnode)
    #         TAX_NODE_OBJ[name] = nnode
    #     prev = TAX_NODE_OBJ[name]
    path_list = path.split(';')
    for i in range(len(path_list)):
        name = ";".join(path_list[:i + 1])
        if name not in TAX_ID:
            ID_COUNT += 1
            TAX_ID[name] = ID_COUNT
        if name not in TAX_NODE_OBJ:
            nnode = TaxNode(TAX_ID[name], data={
                            'name': path_list[i]}, parent=prev)
            prev.child.append(nnode)
            TAX_NODE_OBJ[name] = nnode
        prev = TAX_NODE_OBJ[name]
    return prev


def main():
    # argument parser
    parser = argparse.ArgumentParser()
    parser.add_argument(
        'pos_info', help='position info generated by extract_position.py')
    parser.add_argument('taxonomy', help='taxonomy file (id & path)')
    parser.add_argument('tree_out', help='tree output filename')
    parser.add_argument('tid_out', help='tid output filename')
    args = parser.parse_args()

    # read pos info
    with open(args.pos_info, mode='rb') as fh:
        pos_info = pickle.load(fh)
    # read tax
    with open(args.taxonomy) as fh:
        for line in fh:
            sp_name, path = line.rstrip().split('\t')
            path = path + sp_name
            temp_node = add_node(path)
            temp_node.data['start'] = pos_info[sp_name][0]
            temp_node.data['end'] = pos_info[sp_name][-1]
            TAX_TID[sp_name] = temp_node.tid

    # hit = {652031}
    # stack = [ROOT_NODE]
    # while stack:
    #     pre = stack[-1]
    #     if 'child_done' in pre.data:  # child_done, so cal
    #         pre.data['count'] = sum([x.data['count'] for x in pre.child])
    #         pre.data['cov'] = sum([x.data['cov'] for x in pre.child])
    #         pre.data['done'] = True
    #         print(pre.data)
    #         stack.pop()
    #         continue
    #     count = 0
    #     for curr in pre.child:
    #         if 'done' not in curr.data:
    #             if not curr.child:  # child empty
    #                 curr.data['count'] = 1
    #                 if curr.tid in hit:
    #                     curr.data['cov'] = 1
    #                 else:
    #                     curr.data['cov'] = 0
    #                 curr.data['done'] = True
    #                 continue  # cal next child
    #             stack.append(curr)
    #             break
    #         count += 1
    #     if count == len(pre.child):
    #         pre.data['child_done'] = True

    with open(args.tree_out, mode='wb') as fh:
        pickle.dump(ROOT_NODE, fh)
    with open(args.tid_out, mode='wb') as fh:
        pickle.dump(TAX_TID, fh)


if __name__ == '__main__':
    main()
